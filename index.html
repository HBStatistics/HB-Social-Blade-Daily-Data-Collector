<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HB Statistics • Social Blade Daily Data Collector</title>
  <link rel="icon" href="https://yt3.ggpht.com/veDA1FfRTsN5P5U97lgW9TRP4u0FnGRQIphD1DQs5TRvoHqZHU4xizu0UxIx5GMdnvKa8mkxQzw=s192-c-k-c0x00ffffff-no-rj" />
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;700&display=swap');
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: linear-gradient(135deg, #1f005c, #5b0060, #870160, #a00062);
      font-family: 'Ubuntu', sans-serif;
      color: #eee;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    a { color: #ff6acc; text-decoration: none; transition: color .3s ease; }
    a:hover { color: #ff33ee; }
    header {
      position: sticky; top: 0;
      background: rgba(20,0,60,.85);
      box-shadow: 0 2px 8px rgba(0,0,0,.4);
      padding: 1rem 2rem; display: flex; align-items: center; justify-content: space-between; z-index: 10;
    }
    header h1 { margin: 0; font-weight: 700; font-size: 1.75rem; letter-spacing: 1.3px; user-select: none; }
    main {
      flex-grow: 1; max-width: 960px; margin: 2rem auto 3rem auto;
      background: rgba(10,0,40,.9);
      padding: 2rem 2.5rem; border-radius: 16px; box-shadow: 0 0 30px #a00062aa;
    }
    label[for="rawDataInput"] {
      display: block; font-weight: 700; font-size: 1.25rem; margin-bottom: .5rem; color: #ff99ee; user-select: none;
    }
    textarea#rawDataInput {
      width: 100%; height: 180px; font-family: monospace; font-size: 1rem;
      background-color: #1a002f; border: 2px solid #ff33ee; border-radius: 12px; color: #eee; padding: 1rem;
      resize: vertical; transition: border-color .3s ease; box-shadow: 0 0 15px #ff33ee55 inset;
    }
    textarea#rawDataInput:focus { border-color: #ff66ff; outline: none; box-shadow: 0 0 20px #ff66ffaa inset; }
    .btn {
      background: #ff33ee; color: #fff; font-weight: 700; border: none; border-radius: 12px;
      padding: .75rem 2rem; font-size: 1.1rem; cursor: pointer; margin-top: 1.5rem; box-shadow: 0 0 10px #ff33eeaa;
      transition: background .3s ease, box-shadow .3s ease;
    }
    .btn:hover, .btn:focus { background: #ff66ff; box-shadow: 0 0 20px #ff66ffaa; outline: none; }
    .options { margin-top: 2rem; font-size: 1.1rem; user-select: none; color: #ffc0ff; }
    .options label { cursor: pointer; }
    .options input[type="radio"] { margin-right: .5rem; cursor: pointer; }
    #exData {
      margin-top: 2rem; max-height: 400px; overflow-y: auto; font-family: monospace; background: #2d004f;
      border-radius: 12px; padding: 1.5rem; box-shadow: inset 0 0 15px #ff33ee99; white-space: pre-wrap; color: #ffddff; font-size: .95rem;
    }
    #buttons { margin-top: 1rem; display: flex; flex-wrap: wrap; gap: 12px; }
    #buttons button {
      background: #881166; border-radius: 10px; padding: .5rem 1.3rem; font-size: .9rem; font-weight: 600; color: #fff;
      box-shadow: 0 0 8px #a0329a; transition: background .25s ease; cursor: pointer;
    }
    #buttons button:hover { background: #bb44cc; }
    #exportButtons { margin-top: 2rem; display: flex; gap: 1rem; flex-wrap: wrap; }
    #exportButtons button {
      background: #aa00aa; border-radius: 12px; padding: .75rem 1.8rem; font-size: 1rem; font-weight: 700; color: #ffe6ff;
      box-shadow: 0 0 15px #d241d2cc; cursor: pointer; transition: background .3s ease;
    }
    #exportButtons button:hover { background: #cc33cc; }
    @media (max-width: 600px) {
      main { margin: 1rem; padding: 1.5rem 1.8rem; }
      .btn, #exportButtons button, #buttons button { width: 100%; text-align: center; }
      #buttons, #exportButtons { justify-content: center; }
    }
  </style>
</head>
<body>
  <header>
    <h1>HB Statistics • Social Blade Collector</h1>
  </header>

  <main>
    <label for="rawDataInput">Paste Social Blade Monthly Snapshot Source:</label>
    <textarea id="rawDataInput" placeholder="Paste the full monthly snapshot page source here..."></textarea>
    <button class="btn" type="submit" onclick="addify()">Process Data</button>

    <div id="buttons"></div>

    <div class="options">
      <label><input type="radio" name="hon-vir-data" id="hon" /> Printed data horizontally</label><br />
      <label><input type="radio" name="hon-vir-data" id="vir" checked /> Printed data vertically</label>
    </div>

    <div id="exportButtons">
      <button onclick="downloadCSV()">Export CSV</button>
      <button onclick="downloadJSON()">Export JSON</button>
    </div>

    <label style="font-size: 1.8rem; color: white; margin-top: 2rem; display: block;">Preview</label>
    <div id="exData" aria-live="polite" aria-atomic="true"></div>
  </main>

  <script>
    function copy(text) {
      navigator.clipboard.writeText(text).then(()=>alert('Copied to clipboard!')).catch(()=>alert('Failed to copy!'));
    }

    let countsArrays = { c1: [], c2: [], c3: [], c4: [] };
    let processedData = [];

    function parseDate(str) {
      const d = new Date(str);
      return isNaN(d) ? null : d;
    }
    function formatDate(d) {
      const y = d.getFullYear();
      const m = (d.getMonth() + 1).toString().padStart(2, '0');
      const day = d.getDate().toString().padStart(2, '0');
      return `${y}-${m}-${day}`;
    }

    // === AUTO ESTIMATOR INTERPOLATION SYSTEM (replaces old linear one) ===
    function interpolateAutoEstimator(v1, v2, steps) {
      if (steps <= 0) return [];
      const totalGain = v2 - v1;
      if (totalGain === 0) return Array(steps).fill(v1);
      const avgGain = totalGain / steps;
      const variation = 0.15;
      let increments = Array.from({ length: steps }, () =>
        avgGain * (1 + (Math.random() - 0.5) * variation * 2)
      );
      const sum = increments.reduce((a, b) => a + b, 0);
      increments = increments.map(g => (g * totalGain) / sum);
      const out = [];
      let acc = 0;
      for (let i = 0; i < steps; i++) {
        acc += increments[i];
        out.push(Math.round(v1 + acc));
      }
      if (totalGain > 0) {
        for (let i = 1; i < out.length; i++) {
          if (out[i] < out[i - 1]) out[i] = out[i - 1];
        }
      }
      return out;
    }

    function fillMissingDates(data, dateKey, valueKeys) {
      const filled = [];
      for (let i = 0; i < data.length - 1; i++) {
        const current = data[i];
        const next = data[i + 1];
        filled.push(current);
        const currentDate = parseDate(current[dateKey]);
        const nextDate = parseDate(next[dateKey]);
        const diffDays = Math.round((nextDate - currentDate) / (1000 * 60 * 60 * 24));
        if (diffDays > 1) {
          const interpolations = {};
          valueKeys.forEach(key => {
            const v1 = Number(current[key]) || 0;
            const v2 = Number(next[key]) || v1;
            interpolations[key] = interpolateAutoEstimator(v1, v2, diffDays);
          });
          for (let j = 1; j < diffDays; j++) {
            const newDate = new Date(currentDate);
            newDate.setDate(newDate.getDate() + j);
            const interp = {};
            interp[dateKey] = formatDate(newDate);
            valueKeys.forEach(key => (interp[key] = interpolations[key][j - 1]));
            filled.push(interp);
          }
        }
      }
      filled.push(data[data.length - 1]);
      return filled;
    }
    // ---------- NEW: Views estimation / smoothing utilities ----------
    function findDailyViewsKey(headers) {
      const lc = headers.map(h => h.toLowerCase());
      let idx =
        lc.findIndex(h => h === 'daily views') >= 0 ? lc.findIndex(h => h === 'daily views') :
        lc.findIndex(h => /views.*daily|daily.*views|\bviews\b(?!.*total)/.test(h));
      return idx >= 0 ? headers[idx] : null;
    }

    function findTotalViewsKey(headers) {
      const lc = headers.map(h => h.toLowerCase());
      let idx =
        lc.findIndex(h => h === 'total views') >= 0 ? lc.findIndex(h => h === 'total views') :
        lc.findIndex(h => /cumulative.*views|lifetime.*views|overall.*views|views.*total|total.*views/.test(h));
      return idx >= 0 ? headers[idx] : null;
    }

    // Create mildly varied positive weights that sum to 1
    function randomWeights(n) {
      const w = [];
      for (let i = 0; i < n; i++) w.push(0.9 + Math.random() * 0.2);
      const sum = w.reduce((a,b)=>a+b,0);
      return w.map(x => x / sum);
    }

    // If only daily views exist: smooth windows of 0..0, spike across the zeros + spike day.
    function smoothDailyOnly(rows, dateKey, dailyKey) {
      const n = rows.length;
      let i = 0;
      while (i < n) {
        if (Number(rows[i][dailyKey]) === 0) {
          let start = i;
          while (i < n && Number(rows[i][dailyKey]) === 0) i++;
          const after = i;
          if (after < n && Number(rows[after][dailyKey]) > 0) {
            const spike = Number(rows[after][dailyKey]);
            const windowLen = (after - start) + 1;
            const weights = randomWeights(windowLen);
            const redistributed = weights.map(w => Math.max(0, Math.round(spike * w)));
            const diff = spike - redistributed.reduce((a,b)=>a+b,0);
            if (diff !== 0) redistributed[redistributed.length - 1] += diff;
            for (let k = 0; k < windowLen - 1; k++) rows[start + k][dailyKey] = redistributed[k];
            rows[after][dailyKey] = redistributed[windowLen - 1];
            i = after + 1;
            continue;
          }
        }
        i++;
      }
      return rows;
    }

    // If total views exist: recompute daily as diffs; smooth flats + jump across window; preserve totals exactly.
    function smoothFromCumulative(rows, dateKey, totalKey, dailyKeyOut) {
      const n = rows.length;
      const daily = new Array(n).fill(0);
      for (let i = 1; i < n; i++) {
        const prev = Number(rows[i - 1][totalKey]) || 0;
        const cur  = Number(rows[i][totalKey]) || 0;
        daily[i] = Math.max(0, cur - prev);
      }
      let i = 1;
      while (i < n) {
        const base = Number(rows[i - 1][totalKey]) || 0;
        let flatStart = i;
        while (flatStart < n && Number(rows[flatStart][totalKey]) === base) flatStart++;
        const jumpIdx = flatStart;
        if (jumpIdx < n) {
          const jump = Number(rows[jumpIdx][totalKey]) - base;
          if (jump > 0) {
            const zerosLen = (jumpIdx - i + 1);
            const weights = randomWeights(zerosLen);
            const redistributed = weights.map(w => Math.max(0, Math.round(jump * w)));
            const diff = jump - redistributed.reduce((a,b)=>a+b,0);
            if (diff !== 0) redistributed[redistributed.length - 1] += diff;
            for (let k = 0; k < zerosLen - 1; k++) daily[i + k] = redistributed[k];
            daily[jumpIdx] = redistributed[zerosLen - 1];
          }
          i = jumpIdx + 1;
        } else break;
      }
      for (let k = 0; k < n; k++) rows[k][dailyKeyOut] = Number.isFinite(daily[k]) ? daily[k] : 0;
      return rows;
    }

    function applyViewsEstimation(rows, headers, dateKey) {
      const totalKey = findTotalViewsKey(headers);
      let dailyKey = findDailyViewsKey(headers);
      if (totalKey && !dailyKey) {
        dailyKey = 'Daily Views';
        if (!headers.includes(dailyKey)) headers.push(dailyKey);
        smoothFromCumulative(rows, dateKey, totalKey, dailyKey);
      } else if (totalKey && dailyKey) {
        smoothFromCumulative(rows, dateKey, totalKey, dailyKey);
      } else if (!totalKey && dailyKey) {
        smoothDailyOnly(rows, dateKey, dailyKey);
      }
      return { rows, headers };
    }
    // ---------- END NEW ----------

    function addify() {
      const rawInput = document.getElementById("rawDataInput").value.trim();
      if (!rawInput) return alert("Please paste your Social Blade monthly snapshot source code.");

      countsArrays = { c1: [], c2: [], c3: [], c4: [] };
      processedData = [];

      let acData = rawInput;
      let newACDATA = acData.split('"').join("").split(" + ").join("").split(/\\/g);
      for (let i = 1; i < newACDATA.length; i++) newACDATA[i] = newACDATA[i].split("n").join("");
      newACDATA = newACDATA.join("\n");
      acData = newACDATA;

      const lines = acData.split("\n").filter(line => line.trim() !== "");
      if (!lines.length) return alert("No data lines found. Check your input.");

      const headers = lines[0].split(",").map(h => h.trim());
      if (headers.length < 2) return alert("At least date + 1 data column required.");

      for (let i = 1; i < lines.length; i++) {
        const parts = lines[i].split(",");
        if (parts.length < headers.length) continue;
        const obj = {};
        for (let j = 0; j < headers.length; j++) obj[headers[j]] = parts[j];
        processedData.push(obj);
      }
      if (!processedData.length) return alert("No valid data rows found.");

      processedData.sort((a, b) => {
        const d1 = parseDate(a[headers[0]]);
        const d2 = parseDate(b[headers[0]]);
        if (d1 && d2) return d1 - d2;
        return 0;
      });

      // Auto Estimator fill for missing data
      const valueKeys = headers.slice(1);
      processedData = fillMissingDates(processedData, headers[0], valueKeys);

      // Apply daily/total smoothing
      const result = applyViewsEstimation(processedData, [...headers], headers[0]);
      processedData = result.rows;
      const finalHeaders = result.headers;

      countsArrays.c1 = processedData.map(d => d[finalHeaders[0]]);
      for (let idx = 1; idx < finalHeaders.length; idx++) {
        countsArrays["c" + (idx + 1)] = processedData.map(d => d[finalHeaders[idx]]);
      }

      const exDataDiv = document.getElementById("exData");
      const buttonsDiv = document.getElementById("buttons");
      const isVertical = document.getElementById("vir").checked;

      exDataDiv.innerHTML = "";
      buttonsDiv.innerHTML = "";

      if (isVertical) {
        for (let i = 0; i < processedData.length; i++) {
          const row = processedData[i];
          let line = finalHeaders.map(h => row[h]).join(",");
          exDataDiv.innerHTML += `<span>${line}</span><br>`;
        }
        for (let i = 0; i < finalHeaders.length; i++) {
          countsArrays["c" + (i + 1)] = countsArrays["c" + (i + 1)].join("\n");
          buttonsDiv.innerHTML += `<button onclick="copy(countsArrays.c${i + 1})">Copy "${finalHeaders[i]}"</button>`;
        }
      } else {
        for (let i = 0; i < finalHeaders.length; i++) {
          countsArrays["c" + (i + 1)] = countsArrays["c" + (i + 1)].join("\t");
          let D = countsArrays["c" + (i + 1)].split("\t").join(",");
          exDataDiv.innerHTML += `<span>${finalHeaders[i]},${D}</span><br>`;
          buttonsDiv.innerHTML += `<button onclick="copy(countsArrays.c${i + 1})">Copy "${finalHeaders[i]}"</button>`;
        }
      }
    }

    function downloadCSV() {
      if (processedData.length === 0) return alert("No data to export. Please process data first.");
      const headers = Object.keys(processedData[0]);
      const csvRows = [headers.join(",")];
      for (const row of processedData) {
        const values = headers.map(h => row[h]);
        csvRows.push(values.join(","));
      }
      const csvContent = csvRows.join("\n");
      const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "socialblade_data.csv";
      a.click();
      URL.revokeObjectURL(url);
    }

    function downloadJSON() {
      if (processedData.length === 0) return alert("No data to export. Please process data first.");
      const jsonContent = JSON.stringify(processedData, null, 2);
      const blob = new Blob([jsonContent], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "socialblade_data.json";
      a.click();
      URL.revokeObjectURL(url);
    }
  </script>
</body>
</html>
